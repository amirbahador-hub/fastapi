# ها در پایتون type مقدمه

پایتون از  "type hints" اختیاری (که "type annotations" نیز نامیده می‌شود) پشتیبانی می‌کند.

این  **"type hints"** یا annotations یک syntax خاصی هستند که امکان تعریف <abbr title="برای مثال: str, int, float, bool">type</abbr> را فراهم می‌کند.

با تعریف type  برای متغیرها, editor ها و ابزارها می توانند از شما پشتیبانی بهتری ارائه کنند.

این فقط یک **آموزش/بازنگری سریع** در مورد نکات type hints پایتون است. که فقط حداقل های لازم برای استفاده از آنها با  **FastAPI**... را پوشش می‌دهد که در واقع بسیار کم است.

فریم ورک  **FastAPI** تماما بر اساس این type hint ها می‌باشد, که کلی سود و فایده دارند.

اما اگر حتی هیچوقت  **FastAPI**, استفاده نکنید . از کمی یادگیری  در مورد آنها سود خواهید برد.

!!! توجه
    اگر شما یک متخصص پایتون هستید, و شما از قبل همه چیز را در مورد type hints می‌دانید, به فصل بعدی بروید.

## انگیزه

بیایید با یک مثال ساده شروع کنیم:

```Python
{!../../../docs_src/python_types/tutorial001.py!}
```

خروجی این برنامه:

```
John Doe
```

این فانکشن موارد زیر را انجام می‌دهد:

* یک `first_name` و `last_name` می‌گیرد.
*  با استفاده از `title()` حرف اول هر کدام را با حروف بزرگ تبدیل می کند.
* آنها را با یک فاصله در وسط به هم <abbr title="در کنار هم قراردادن, به عنوان یک واحد. با مطالب یکی پس از دیگری.">Concatenates(متصل)</abbr> می‌کند.

```Python hl_lines="2"
{!../../../docs_src/python_types/tutorial001.py!}
```

### ویرایش کنید

این یک برنامه بسیار ساده است.

اما حالا تصور کنید که آن را از ابتدا می نوشتید.

در مقطعی از زمان, تعریف تابع را شروع می کردید, پارامتر ها را آماده می‌کردید و ...

اما پس از آن باید "آن method ای که حرف اول را به حروف بزرگ تبدیل می کند" را فراخوانی کنید.

چی بود `upper` بود?`uppercase` بود? `first_uppercase`? `capitalize`?

سپس, سعی می‌کنی با دوست قدیمی برنامه نویس ها, editor autocompletion(تکمیل خودکار) امتحان کنی.

اولین پارامتر function را تایپ می کنید, `first_name`, و بعد یک نقطه (`.`) می گذارید و بعد برای راه انداختن completion(تکمیل خودکار)
 `Ctrl+Space` فشار می‌دهید  .

اما, متاسفانه, هیچ چیز مفیدی دریافت نمی کنید:

<img src="/img/python-types/image01.png">

### اضافه کردن types

بیایید یک خط را از نسخه قبلی اصلاح کنیم.

ما دقیقاً این تکه, پارامترهای function را, از این:

```Python
    first_name, last_name
```

به:

```Python
    first_name: str, last_name: str
```

تغییر می‌دهیم همین.

این ها "type hints" هستند:

```Python hl_lines="1"
{!../../../docs_src/python_types/tutorial002.py!}
```

این مشابه با اعلام مقادیر پیش‌فرض نیست:

```Python
    first_name="john", last_name="doe"
```

این یک چیز متفاوت است.

ما داریم از دو نقطه استفاده می‌کنیم (`:`), نه تساوی (`=`).

و افزودن type hints معمولا آنچه را که اتفاق می افتد با آنچه که بدون آنها اتفاق می افتد تغییر نمی دهد.

اما حالا, تصور کنید که دوباره در وسط ایجاد آن تابع هستید, اما با type hints.

در مرحله ای, شما سعی می کنید تکمیل خودکار را با `Ctrl+Space` اعمال کنید ولی می‌بینید:

<img src="/img/python-types/image02.png">

با اون, می‌تونید scroll کنید, و گزینه هارو ببینید, تا وقتی که اونی رو پیدا کنید که "جرقه ای در ذهنتون ایجاد می‌کنه":

<img src="/img/python-types/image03.png">

## انگیزه بیشتر

این function را بررسی کنید, از قبل دارای  type hints می‌باشد:

```Python hl_lines="1"
{!../../../docs_src/python_types/tutorial003.py!}
```

چون editor از type های متغیر ها آگاهی داره, نه تنها قابلیت تکمیل خودکار دارید , بلکه قابلیت error checks(بررسی خطا) نیز دریافت می‌کنید:

<img src="/img/python-types/image04.png">

حالا می دانید که باید آن را درست کنید, با استفاده از `str(age)` باید `age` رو به string تبدیل کنید :

```Python hl_lines="2"
{!../../../docs_src/python_types/tutorial004.py!}
```

## تعریف type ها

شما الان محل اصلی تعریف  type hints را دیدید. به عنوان پارامتر های function.

همچنین این جای اصلی است که می توانید از آنها در  **FastAPI** استفاده کنید.

### بررسی type های ساده

شما می‌توانید تمام type های استاندارد پایتون را تعریف کنید, نه فقط `str`.

برای مثال:

* `int`
* `float`
* `bool`
* `bytes`

```Python hl_lines="1"
{!../../../docs_src/python_types/tutorial005.py!}
```

### جنریک type ها با type پارامترها

برخی از ساختمان داده ها وجود دارند که می توانند مقادیر دیگری را دربر گیرند, مثل `dict`, `list`, `set` و `tuple`. و مقادیر داخلی نیز می توانند type خودشون رو داشته باشند.

به این type ها که دارای type های داخلی هستند  "**generic**" types گفته می‌شود. و تعریف اونها حتی با,  type های داخلیشون امکان پذیر می‌باشد.

برای تعریف این type ها و type های داخلیشون, می توانید از ماژول استاندارد پایتون `typing` استفاده کنید. که به طور خاص برای پشتیبانی از این type hints وجود دارد.

#### نسخه های جدیدتر پایتون

سینتکسی که از `typing` استفاده می‌کند با  تمام نسخه ها, از Python 3.6 تا نسخه های اخیر که شامل,  Python 3.9, Python 3.10, و غیره می‌شود  **سازگار** است.

با پیشرفت پایتون, **نسخه های جدیدتر**با پشتیبانی بهبود یافته از این type annotation ها ارائه می شوند و در بسیاری از موارد به import کردن ماژول `typing` برای تعریف type annotations نیازی نخواهید داشت.

اگر می توانید نسخه جدیدتر پایتون را برای پروژه خود انتخاب کنید, شما قادر خواهید بود از این سادگی بیشتر استفاده کنید.

در تمام داکیومنت ها نمونه هایی وجود دارد که با هر نسخه از پایتون سازگار است (وقتی تفاوت وجود دارد).

برای مثال "**Python 3.6+**"  یعنی با پایتون 3.6 یا بالاتر سازگاری دارد(شامل 3.7, 3.8, 3.9, 3.10, غیره). و "**Python 3.9+**" بدین معناست که با پایتون 3.9 یا بالاتر سازگاری دارد (شامل 3.10, غیره).

اگر می‌تونید از **آخرین نسخه پایتون** استفاده کنید, از مثال های آخرین ورژن استفاده کنید, اینها داری **بهترین و  ساده ترین سنیتکس** خواهند بود, برای مثال, "**Python 3.10+**".

#### بررسی List

برای مثال, بیاید متغیری تعریف کنیم که `list` ای از `str` خواهد بود.

=== "Python 3.9+"

    تعریف متغیر , با استفاده از سینتکس دو نقطه (`:`).

    به عنوان type, `list` را قرار بده.

    از اونجایی که list یک type هست که شامل مقادیر داخلی می‌باشد, می‌تونیم type اشون رو داخل کروشه قرار دهیم:

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial006_py39.py!}
    ```

=== "Python 3.6+"

    از `typing`, import می‌کنیم `List` رو (با `L` بزرگ):

    ``` Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial006.py!}
    ```

    تعریف متغیر, با استفاده از همون سینتکس دو نقطه (`:`).

    به عنوان type, `List` را که از `typing` import شده است قرار می‌دهیم .

    از اونجایی که list یک type هست که شامل مقادیر داخلی می‌باشد, می‌تونیم type اشون رو داخل کروشه قرار دهیم:

    ```Python hl_lines="4"
    {!> ../../../docs_src/python_types/tutorial006.py!}
    ```

!!! اطلاعات
    اون type های داخلی درون کروشه ها رو "type parameters" می‌گویند.

    در این حالت, `str` یک type parameter هست که `List` پاس داده شده است(یا `list` در پایتون 3.9 و بالاتر).

که بدین معناست: "متغیر `items` یک `list` است, و هرکدام از item ها در این list یک `str` است".

!!! نکته
    اگر شما از پایتون 3.9 یا بالاتر استفاده می‌کنید, لازم نیست `List` را از `typing` import کنید, می‌تونید به جاش از همون `list` معمولی به عنوان type استفاده کنید.

با انجام این کار, editor شما حتی در حین پردازش item ها از list می‌تونه پشتیبانی کنه:

<img src="/img/python-types/image05.png">

بدون type ها, دستیابی به آن تقریبا غیرممکن است.

توجه داشته باشید که متغیر `item` یکی از عناصر لیست `items` است.

و همچنان, editor می‌دونه که `str` هستش, و پشتیبانیش رو فراهم می‌کنه.

#### Tuple و Set

 همین کار را برای تعریف `tuple`ها و `set`ها انجام می‌دهید:

=== "Python 3.9+"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial007_py39.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial007.py!}
    ```

این یعنی:

* متغیر `items_t` یک `tuple` هست شامل سه item, یک `int`, یک `int` دیگر, و یک `str`.
* متغیر `items_s` یک `set` می‌باشد, و هرکدام از item ها از type `bytes` است.

#### Dict

برای تعریف `dict`, شما دو type parameters باید پاس بدهید, که با یک ویرگول از هم مجزا شده اند.

اولین type parameter برای key های `dict` است.

دومین type parameter برای value های `dict` است:

=== "Python 3.9+"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial008_py39.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial008.py!}
    ```

این یعنی:

* متغیر `prices` یک `dict` می باشد:
    * کلید های این `dict` از type `str` هستند(اسم هر آیتم مثلا).
    * مقادیر این `dict` از type `float` می‌باشد(قیمت هر آیتم مثلا).

#### Union

شما می‌تونید متغیری تعریف کنید که شامل **چندین types** باشه, مثلا, یک `int` و یا یک `str`.

در پایتون 3.6 و بالاتر (شامل پایتون 3.10) شما می‌تونید از `Union` type در `typing` استفاده کنید و داخل کروشه type هایی رو که می‌تونه بپذیره رو قرار می‌دهید.

در پایتون 3.10 یک **سنتکس جدید** که  می‌تونید type هایی رو که می‌تونه بپذیره اضافه شده رو با یک <abbr title='بهش "bitwise یا operator" هم می‌گویند, اما معنیش اینجا خیلی ارتباطی ندارد'>خط عمودی (`|`)</abbr> از هم جدا کنید.

=== "Python 3.10+"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial008b_py310.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial008b.py!}
    ```

در دوحالت به این معنی هستش که `item` می‌تونه یک `int` یا یک `str` باشه.

#### بررسی `None` محتمل

می توانید تعریف کنید که یک مقدار می تواند یک type داشته باشد, مثل `str`, اما همچنین می تواند `None` باشد.

در  پایتون 3.6 و بالاتر (شامل پایتون 3.10) شما می‌تونید با import و استفاده کردن از `Optional` در ماژول `typing` تعریفش کنید.

```Python hl_lines="1  4"
{!../../../docs_src/python_types/tutorial009.py!}
```

استفاده از `Optional[str]` به جای فقط `str` به editor اجازه می‌ده که بتواند به شما کمک کند تا خطاهایی را شناسایی کنید که می توانید فرض کنید یک مقدار همیشه یک `str` است, در حالی که می‌تونه درواقع `None` هم باشد.

`Optional[یه چیزی]` در اصل کوتاه شده‌ی `Union[یه چیزی, None]`, است آنها معادل هستند.

این نیز به این معنی است که در پایتون 3.10, شما می‌تونید از `یه چیزی | None` استفاده کنید:

=== "Python 3.10+"

    ```Python hl_lines="1"
    {!> ../../../docs_src/python_types/tutorial009_py310.py!}
    ```

=== "Python 3.6+"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial009.py!}
    ```

=== "Python 3.6+ alternative"

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial009b.py!}
    ```

#### استفاده از `Union` یا `Optional`

اگر از پایتون نسخه قبل از 3.10 استفاده می‌کنید, این یک نکته دیدگاه خیلی  **subjective(ذهنی)** هستش:

* 🚨 از استفاده از `Optional[SomeType]` دوری کنید
* بجاش از ✨ **`Union[SomeType, None]` استفاده کنید** ✨.

هر دو معادل هستند و در زیر آنها یکسان هستند, اما من `Union` رو به جای `Optional` توصیه می‌کنم چون کلمه "**Optional**" به نظر می رسد به این معنی است که مقدار اختیاری است, اما در حقیقت به این معنی هستش که "می‌تونه `None` باشه", حتی اگر اختیاری نباشد و همچنان مورد نیاز باشد.

من فکر می‌کنم `Union[SomeType, None]` در مورد معنای آن واضح تر است.

این فقط در مورد کلمات و اسامی است. اما این کلمات می توانند بر نحوه تفکر شما و هم تیمی هایتان در مورد کد تأثیر بگذارند.

به عنوان مثال, بیاید این function رو بررسی کنیم:

```Python hl_lines="1  4"
{!../../../docs_src/python_types/tutorial009c.py!}
```

پارامتر `name` به عنوان `Optional[str]` تعریف شده, اما **انتخابی نیست**, شما بدون پارامتر نمی‌تونید این funciton رو صدا بزنید:

```Python
say_hi()  # اوه, نه, این ارور می‌ده! 😱
```

پارامتر `name` یک پارامتر  **ضروری** هست  (نه  *اختیاری*) چون مقدار پیش فرض نداره. همچنان, `name`  `None` رو به عنوان مقدار قبول می کنه:

```Python
say_hi(name=None)  # این کار می‌کنه, None صحیح است 🎉
```

خبر خوب اینه که, وقتی برید روی پایتون 3.10 شما در مورد آن نگران نخواهید بود, چون به سادگی از`|` برای تعریف Union استفاده خواهید کرد:

```Python hl_lines="1  4"
{!../../../docs_src/python_types/tutorial009c_py310.py!}
```

و دیگر لازم نیست نگران نام هایی مانند `Optional` و `Union` باشید. 😎

#### بررسی type های جنریک

این type ها که  type parameters داخل کروشه می‌گیرند رو بهشون  **Generic types** یا **Generics** می‌گویند, برای مثال:

=== "Python 3.10+"

    می‌تونید از همون type های داخلی به عنوان generic ها استفاده کنید (با یک کروشه و type های داخلش):

    * `list`
    * `tuple`
    * `set`
    * `dict`

    و عین همون در پایتون نسخه 3.6, در ماژول `typing`:

    * `Union`
    * `Optional` (مانند پایتون 3.6)
    * ...و بقیه.

    در پایتون 3.10, یک جایگزین برای generic های `Union` و `Optional` وجود دارد, می‌تونید از <abbr title='با نام های "bitwise یا operator" هم شناخته می‌شوند, اما این معنا به اینجا مربوط نیست'>خط عمودی (`|`)</abbr> برای تعریف type های unions استفاده کنید, این خیلی بهتر و ساده تر است.

=== "Python 3.9+"

    می‌تونید از همون type های داخلی به عنوان generic ها استفاده کنید (با یک کروشه و type های داخلش):

    * `list`
    * `tuple`
    * `set`
    * `dict`

    و عین همون در پایتون نسخه 3.6, در ماژول `typing`:

    * `Union`
    * `Optional`
    * ...و بقیه.

=== "Python 3.6+"

    * `List`
    * `Tuple`
    * `Set`
    * `Dict`
    * `Union`
    * `Optional`
    * ...و بقیه.

### Classe ها به عنوان types

شما همچنین می‌تونید از class به عنوان type متغیر استفاده کنید.

فرض کنید class دارید به اسم `Person`, با یک name:

```Python hl_lines="1-3"
{!../../../docs_src/python_types/tutorial010.py!}
```

حالا می‌تونید متغیری با type `Person` تعریف کنید:

```Python hl_lines="6"
{!../../../docs_src/python_types/tutorial010.py!}
```

و بعد, دوباره, تمام پشتیبانی editor رو هم استفاده می‌کنید:

<img src="/img/python-types/image06.png">

توجه کنید که این یعنی "`one_person` یک  **instance** از کلاس `Person` است".

و به  معنی "`one_person` همون **class** به اسم `Person` نیست".

## Pydantic models

<a href="https://pydantic-docs.helpmanual.io/" class="external-link" target="_blank">Pydantic</a> یک کتابخانه پایتون برای انجام اعتبارسنجی داده ها است.

شما "شکل" داده ها را به عنوان class هایی با attribute ها تعریف می کنید. .

و هر attribute یک type داره.

و بعد یک instance از اون class را با یکسری مقادیر می‌سازید و اون مقادیر رو validate می‌کنه, و به type درست تبدیلشون می‌کنه (اگر اینطور باشد) و بهتون یک object با تمام دیتا ها می‌دهد.

و شما پشتیبانی editor رو برای تمامی نتیجه ها بدست می‌آورید.

یک مثال از داکیومنت رسمی Pydantic:

=== "Python 3.10+"

    ```Python
    {!> ../../../docs_src/python_types/tutorial011_py310.py!}
    ```

=== "Python 3.9+"

    ```Python
    {!> ../../../docs_src/python_types/tutorial011_py39.py!}
    ```

=== "Python 3.6+"

    ```Python
    {!> ../../../docs_src/python_types/tutorial011.py!}
    ```

!!! اطلاع
    برای یادگیری بیشتر <a href="https://pydantic-docs.helpmanual.io/" class="external-link" target="_blank">Pydantic, داکیومنت هاش رو بررسی کنید</a>.

فریم ورک **FastAPI** تماما بر اساس Pydantic می‌باشد.

خیلی بیشتر ازش رو در عمل خواهی دید [Tutorial - User Guide](tutorial/index.md){.internal-link target=_blank}.

!!! نکته
    Pydantic  وقتی از `Optional` یا `Union[Something, None]` بدون مقدار پیش فرض استفاده می‌کنید یک عملکرد بخصوص دارد, می‌تونید در داکویمنت Pydantic بیشتر در موردش مطالعه کنید<a href="https://pydantic-docs.helpmanual.io/usage/models/#required-optional-fields" class="external-link" target="_blank">فیلدهای اختیاری ضروری</a>.

## Type Hints با Metadata Annotations

پایتون همچنین یک قابلیت ای دارد که اجازه می‌دهد **اطلاعات اضافی** در این type hint ها با استفاده از  `Annotated` قرار دهید.

=== "Python 3.9+"

    در پایتون 3.9, `Annotated` یک قسمتی از standard library می‌باشد, پس می‌تونید از `typing` import اش کنید.

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial013_py39.py!}
    ```

=== "Python 3.6+"

    در نسخه های قبل از 3.9, شما می‌تونید `Annotated` رو از `typing_extensions` اضافه کنید.

    که بصورت خودکار از قبل با **FastAPI** نصب می شود.

    ```Python hl_lines="1  4"
    {!> ../../../docs_src/python_types/tutorial013.py!}
    ```

خود پایتون هیچ کاری با این `Annotated` انجام نمی‌دهد. همچنین editor ها و بقیه ابزار ها هم کاری نمی‌کنند,  type همچنان `str` می‌باشد.

اما می‌تونید از این فضای  `Annotated` استفاده کنید که برای  **FastAPI** اطلاعات متادیتای اضافی که اپلیکیشن چگونه عمل می‌کند فراهم کنید.

نکته مهمی که باید یادمون باشه اینه که **اولین *type parameter*** که به `Annotated` پاس می‌دهید **خود type است**. و بقیه, فقط metadata برای بقیه ابزار ها می‌باشند.

فعلا, فقط کافیه بدونید که  `Annotated` وجود داره, و پایتون استاندارد هستش. 😎

بعدا خواهید دید که چقدر **قدرتمند** می‌تونه باشه.

!!! نکته
    این که  **پایتون استاندارد هستش** به این معناست که شما  **بهترین تجربه توسعه دهنده ممکن** رو داخل editor, و بقیه ابزار ها که برای تحلیل و ریفکتور کردن کد و... بدست می‌آورید . ✨

    و همچنین اینکه کد شما با بسیاری از ابزارها و کتابخانه های پایتون بسیار سازگار خواهد بود. 🚀

## Type hints در  **FastAPI**

فریم ورک **FastAPI** از این type hints برای چند منظور استفاده می‌کند.

با **FastAPI** با تعریف parameter ها با type hints خواهید داشت:

* **پشتیبانی Editor**.
* **بررسی Type**.

...و **FastAPI** از این تعاریف استفاده می‌کند که:

* **تعریف requirements**: از parameter های مسیر درخواست گرفته تا, query parameters, headers, bodies, dependencies, و غیره.
* **تبدیل data**: از request به type ضروری.
* **اعتبار سنجی data**: با هر درخواست:
    * وقتی  دیتا  invalid باشه **خطای اوتوماتیک** تولید می‌شه که به کلاینت برمی‌گردونه.
* **داکیومنت** API از OpenAPI استفاده می‌کنه:
    * که سپس توسط رابط های کاربر داکیومنت تعاملی خودکار استفاده می شود.

همه اینها ممکن است انتزاعی به نظر برسد. نگران نباشید. همه اینها را در عمل خواهید دید در داخل [Tutorial - User Guide](tutorial/index.md){.internal-link target=_blank}.

نکته مهم این است که با استفاده از types پایتون استاندارد, در یک مکان (به جای اضافه کردن چند classes, decorators, etc), **FastAPI** بسیاری از کارها را برای شما انجام خواهد داد.

!!! اطلاع
    اگر قبلاً تمام آموزش‌ها را گذرانده‌اید و برای دیدن اطلاعات بیشتر در مورد انواع برگشته‌اید, یک منبع خوب <a href="https://mypy.readthedocs.io/en/latest/cheat_sheet_py3.html" class="external-link" target="_blank"> "cheat sheet" از `mypy`</a> هست.
